---
title:  "Docker"
categories: technology
toc: true
tags:
  - devops
  - container
---
## Introduction
Post n√†y s·∫Ω t·∫≠p trung n√≥i v·ªÅ Docker, image, container, docker compose. N·∫øu ƒë√£ l√†m quen v·ªõi c√°c kh√°i ni·ªám th√¨ b·∫°n c√≥ th·ªÉ nh·∫£y v√†o c√°c ph·∫ßn Example lu√¥n ƒë·ªÉ th·ª±c h√†nh.


## Glossary
- namespaces, cgroups: feature exists in Linux kernel
- daemon: a background process that handles requests for services such as print spooling and file transfers, and is dormant when not required.
- Dangling image: an image that is no longer tagged, appears in `<none>:<none>`
- Ephemeral serverless backend: backend is so highly virtualized that the concept of a host or node no longer has any meaning - your container simply runs, and you don't need to care about the how or where.


## Architecture of Docker
### Advantages of Docker
- **Separate your applications from your infrastructure**, t·ª´ ƒë√≥ c√≥ th·ªÉ deploy nhanh ch√≥ng h∆°n.

### So s√°nh Virtualization vs Containerlization
Virtualization:
- V·ªÅ t√†i nguy√™n: khi ch·∫°y m√°y ·∫£o ph·∫£i cung c·∫•p dung l∆∞·ª£ng ·ªï c·ª©ng, c≈©ng nh∆∞ ram cho m√°y ·∫£o ƒë√≥.
- V·ªÅ th·ªùi gian: kh·ªüi ƒë·ªông, shutdown kh√° l√¢u.

Containerlization:
- Tr√™n m√°y ch·ªß v·∫≠t l√Ω s·∫Ω sinh ra ƒë∆∞·ª£c nhi·ªÅu m√°y con (gi·ªëng virtualization) nh∆∞ng t·ªët h∆°n ·ªü ch·ªó c√°c m√°y con (Guest OS) ƒë·ªÅu d√πng chung ph·∫ßn nh√¢n c·ªßa m√°y m·∫π (Host OS) v√† chia s·∫ª t√†i nguy√™n m√°y m·∫π.
-> Khi n√†o c·∫ßn t√†i nguy√™n th√¨ c·∫•p, c·∫ßn bao nhi√™u th√¨ c·∫•p b·∫•y nhi√™u -> t·∫≠n dung t√†i nguy√™n t·ªët h∆°n.
-> ch·ªâ c·∫ßn license cho host os.

At a high level, hypervisors perform hardware virtualization - they carve up physical hardware resources into virtual versions called VMs. On the other hand, containers perform OS virtualization - the carve OS resources into virtual versions called containers.

Containers are less secure and provide less workload isolation than VMs. Technologies exist to secure containers and lock them down, but some of them are prohibitively complex.

### Installation
C√†i ƒë·∫∑t b·∫£n Community Docker, v·ªõi Mac v√† Win c·∫ßn c√†i Docker Desktop (VM ƒë·ªÉ ch·∫°y docker). C√≥ th·ªÉ c·∫ßn th√™m user account v√†o group Docker ƒë·ªÉ ch·∫°y kh√¥ng c·∫ßn sudo.
```bash
docker version
```

### Components of Docker
![Architecture](/handbook/assets/images/docker/Untitled.png)

2 Major components:
- Docker client:
  - Client g·ªçi Daemon th√¥ng qua local IPC/Unix socket ·ªü /var/run/docker.sock
- Docker engine: 
  - implements the runtime, API and everything else required to run Docker.
  - modular in design, built from many small specialized tools. (ƒë√¢y l√† k·∫øt qu·∫£ c·ªßa qu√° tr√¨nh refactor nh·∫±m chia nh·ªè docker daemon).

![Architecture2](/handbook/assets/images/docker/Untitled%201.png)

Inside Docker Engine:
- Docker daemon: some major functionality still exists: image management, image builds, the REST API, authentication, security, core networking, and orchestration
- runc: has a single purpose is to create containers. It's a standalone container runtime tool. (t·ª± exit sau khi t·∫°o xong).
- containerd: manage container lifecycle operations (start, stop, pause, rm,...) and some extended functionality (for images, volumes and networks) to make it easier to use in other projects.
- shim:
  - Keeping any STDIN and STDOUT streams open so that when the daemon is restared, the container doesn't terminate due to pipes being closed.
  - Reports the container's exit status back to the daemon.


  ‚Üí entire container runtime is decoupled from the Docker daemon. ‚Üí "daemonless containers" ‚Üí c√≥ th·ªÉ upgrade daemon m√† kh√¥ng c·∫ßn t·∫Øt container.


## Working with Images
![Docker Images](/handbook/assets/images/docker/Untitled%203.png)

An image is just a bunch of loosely-connected read-only layers, with each layer comprising one or more files. Images don't contain kernel - all containers running on a Docker host share access to the host's kernel. One image can have several tags (tags point to the same image id).

Multi-architecture Images: h·∫ßu h·∫øt c√°c official image tr√™n Docker Hub ƒë·ªÅu h·ªó tr·ª£ multi-architecture m√† kh√¥ng c·∫ßn khai b√°o architecture.

### Examples
```bash
docker image ls
docker pull [REPO:TAG]
docker search [QUERY_STRING]

# show all images
docker images

docker image inspect [IMAGE]

# delete image, you need to delete all dependent containers first
docker rmi <image>
# Delete all dangling images
docker image prune
# Delete all unused images (not currently used by any containers)
docker image prune -a

# Delete all images
docker image rm $(docker ls -q) -f


# RUN CONTAINER FROM AN IMAGE
docker run [IMAGE]
docker run -it [IMAGE]  # start a container
docker run -it [IMAGE] [CMD] # override the default command
# options:
# -i : interaction mode
# -d : detach mode
# -v <outside_volume>:<inside_volume> : mount volume
# -e MY_VAR=my_value : set envvars.
```

## Working with Containers
Docker sinh ra ƒë·ªÉ ch·∫°y application, ch·ª© kh√¥ng ch·∫°y ƒë·ªÉ host OS, n·∫øu kh√¥ng application n√†o th√¨ n√≥ s·∫Ω t·ª± ƒë·ªông exit. Docker s·∫Ω ch·∫°y ·ªü hai ch·∫ø ƒë·ªô attach v√† detach. V√† docker c≈©ng s·∫Ω kh√¥ng listen ·ªü stdin theo m·∫∑c ƒë·ªãnh (non-interact mode).

Kill the main process in the container will kill the container. Container c≈©ng ho·∫°t ƒë·ªông gi·ªëng VM ·ªü kho·∫£n n·∫øu stop th√¨ d·ªØ li·ªáu trong container v·∫´n ƒë∆∞·ª£c gi·ªØ. (ƒëi·ªÅu n√†y c≈©ng ko qu√° quan tr·ªçng v√¨ c√≥ bi·ªán ph√°p t·ªët h∆°n cho v·∫•n ƒë·ªÅ n√†y ƒë√≥ l√† s·ª≠ d·ª•ng volume).


### Examples
```bash
docker ps       # show running containers
docker ps -a    # show all containers

docker start/stop [CONTAINER]
# stop here mean sending a SIGTERM signal to the main process (PID 1). After 10s, if it doesn't exit, it will receive a SIGKILL.


# execute a command
docker exec [CONTAINER] [COMMAND]

# E.g: docker exec -it my_container /bin/bash 
# -> re-attach to the container by creating another bash shell. 

docker attach [CONTAINER]

# show full details of a container
docker inspect [CONTAINER]

docker logs [CONTAINER]

docker rm [CONTAINER]
# delete a running container (sending SIGKILL)
docker rm -f [CONTAINER]



# Press Ctrl + P Q to exit the container without terminating it.

```

### Restart Policies
This is a form of self-healing that enables Docker to automatically restart container after certain events or failures have occurred. The policy is applied per container.

3 policies:
- always
- unless-stopped: khi docker daemon kh·ªüi ƒë·ªông m√† container ·ªü tr·∫°ng th√°i Stopped th√¨ s·∫Ω ko ƒë∆∞·ª£c restart.
- on-failed: kh·ªüi ƒë·ªông khi nh·∫≠n ƒë∆∞·ª£c non-zero exit code.

```bash
docker run -it --restart always --name my_container my_image /bin/bash

docker update --restart=no my_container
```

You can see the `restartCount` if you inspect that container.



## Commit the changes from container into a new image
In general, it is better to use dockerfile to manage and maintain images. However, during development process, the very first initialized images are often not sufficient of requirements or bug-free. Hence, the final stable versions of an image need to commited. This commit operation will not include any data contained in volumes mounted inside the container. 

```bash
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
```

### Options

| options       | default | description |
| :-----------: | :-----: | :---------: |
| --author, -a  |         | author      |
| --change, -c  |         | apply Dockerfile instruction to the create image |
| --message, -m |         | commit message |
| --pause, -p   |   true  | pause the container during commit |

**Note:** 

- As the --pause value is true by default, the container will be paused during the process of commiting. This should curb the risk of corrupting data during the process of creating new image. If it is undesired, set it to false. 
- The --change option will apply Dockerfile instructions to the image that is created including supported fundamental instructions CMD, ENTRYPOINT, ENV, EXPOSE, LABEL, ONBUILD, USER, VOLUME, WORKDIR

### Examples

```bash
# commit with --change
docker commit --change "ENV DEBUG=true" [CONTAINER]
# or 
$ docker commit --change='CMD ["apachectl", "-DFOREGROUND"]' -c "EXPOSE 80" [CONTAINER]

```



## Containerizing an app
Containers are all about making apps simple to build, ship and run.

Build context: the directory containing the application and dependencies.
-> your dockerfile should be keeped in the root directory of the build context.


### Dockerfile
Dockerfile l√† m·ªôt file text gi√∫p Docker t·∫°o image. M·ªói d√≤ng s·∫Ω bao g·ªìm 2 ph·∫ßn: instruction v√† argument. Sau m·ªói d√≤ng l·ªánh, m·ªôt layer s·∫Ω ƒë∆∞·ª£c t·∫°o ra ƒë·ªÉ cache. -> Kh√¥ng m·∫•t c√¥ng t·∫°o l·∫°i to√†n b·ªô khi c√≥ sai s√≥t.

T·∫•t c·∫£ image ph·∫£i base tr√™n m·ªôt base image kh√°c (OS).

Example:
```dockerfile
FROM alpine
LABEL maintainer="nigelpoulton@hotmail.com"

RUN apk add --update nodejs nodejs-npm
COPY . /src
WORKDIR /src
RUN npm install

EXPOSE 8080
ENTRYPOINT ["node", "./app.js"]
CMD ["exe1", "param1"]
# CMD exe1 param1
ENTRYPOINT ["exe2"]
```

Example: Python app
```dockerfile
FROM python:3.8

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

RUN apt-get update
RUN apt-get install ffmpeg -y

WORKDIR /code

COPY requirements.txt /code/

RUN pip install -r requirements.txt

COPY . /code/
```

Build new image
```bash
docker build [BUILD_CONTEXT]
docker build [BUILD_CONTEXT] -t [IMAGE_NAME:TAG]
# E.g:
# docker build -t my_img:latest.

docker push [IMAGE]
```

**Best practices:**
Khi t·∫°o Docker image th√¨ lu√¥n ƒë·ªÉ nh·ªØng th√†nh ph·∫ßn thay ƒë·ªïi nhi·ªÅu xu·ªëng b√™n d∆∞·ªõi. ·ªû v√≠ d·ª• tr√™n, c·∫ßn copy requirements.txt v√†o tr∆∞·ªõc c≈©ng v√¨ th·∫ø.

Vi·ªác c√≥ nhi·ªÅu instruction s·∫Ω d·∫´n ƒë·∫øn vi·ªác c√≥ nhi·ªÅu layer -> tƒÉng size c·ªßa image. ƒê·ªÉ h·∫°n ch·∫ø, c√≥ th·ªÉ g·ªôp c√°c l·ªánh RUN l√†m 1 v·ªõi &&.
C√°i th·ª© 2 l√† th∆∞·ªùng m√¨nh kh√¥ng clean c√°c file kh√¥ng c·∫ßn thi·∫øt (tools) sau khi build xong.

-> Gi·∫£i ph√°p l√† s·ª≠ d·ª•ng multi-stage build: M·ªôt dockerfile c√≥ nhi·ªÅu stage, v·ªõi stage cu·ªëi c√πng ch·ªâ c·∫ßn copy c√°c file c·∫ßn thi·∫øt (production-related) t·ª´ stage tr∆∞·ªõc ƒë√≥ v√†o ƒë·ªÉ ch·∫°y.

Ngo√†i ra, c≈©ng c√≥ nhi·ªÅu tutorial h∆∞·ªõng d·∫´n t·ªëi ∆∞u ho√° qu√° tr√¨nh build (squashing, no-install-recommends,...).



Ngo√†i ra, n√™n xem th√™m ph·∫ßn Best Practices ·ªü cu·ªëi b√†i.


### .dockerignore
Th∆∞·ªùng th√¨ s·∫Ω ignore folder .git v√† .env




## Docker Compose
Thay v√¨ ch·∫°y t·ª´ng l·ªánh `docker run` ri√™ng l·∫ª kia th√¨ ta c√≥ th·ªÉ s·ª≠ d·ª•ng Docker compose (ph√π h·ª£p v·ªõi c√°c ·ª©ng d·ª•ng microservices). V·ªÅ c∆° b·∫£n th√¨ l√† t·∫°o m·ªôt file `docker-compose.yml`, trong ƒë√≥ li·ªát k√™ c√°c service k√®m theo setting c·∫ßn t·∫°o.

```bash
docker-compose up/down/restart
docker-compose ps
docker-compose top

# delete stopped containers and networks only.
docker-compose rm
```
L√∫c n√†y, t√™n c·ªßa c√°c container s·∫Ω c√≥ prefix l√† t√™n c·ªßa build context directory v√† numeric suffix ch·ªâ instance number (v√¨ Compose h·ªó tr·ª£ scaling).

V√≠ d·ª•:
```yml
version: "3.8" 

services:
  web-fe:
    build: .
    command: python app.py 
    ports:
    - target: 5000
      published: 5000
    networks:
      - counter-net
    volumes:
      - type: volume
        source: counter-vol
        target: /code 
  redis:
    image: "redis:alpine" 
    networks:
      counter-net:

networks: 
  counter-net:

volumes: 
  counter-vol:
```

Networks: tell Docker to create new networks. By default, Compose will create `bridge` networks. These are single-host networks that can only connect containers on the same Docker host. However, you can use `drive` property to specify different network types.
```yml
networks:
  over-net:
  driver: overlay
  attachable: true
```
Volumes: tell Docker to create new volumes.



## Docker Network
Khi t·∫°o container th√¨ n√≥ s·∫Ω c√≥ th·ªÉ c√≥ 3 ch·∫ø ƒë·ªô network: bridge (default), none, host

```bash
# bridge
docker run ubuntu
# none
docker run ubuntu --network
```

**Bridge**: private internal network created by docker on the host. All containers attach to this network, th∆∞·ªùng s·∫Ω c√≥ d·∫£i 172.17.0.xxx. C√°c container c√≥ th·ªÉ k·∫øt n·ªëi v·ªõi nhau th√¥ng qua d·∫£i n√†y.

**Host**: t·ª± ƒë·ªông mapping port, s·ª≠ d·ª•ng host network -> Kh√¥ng th·ªÉ s·ª≠ d·ª•ng container tr√πng port.

**None**: c√¥ l·∫≠p.


### User-defined networks
Docker c√≥ th·ªÉ chia nhi·ªÅu private internal network.

```bash
docker network create --driver bridge --subnet 182.18.0.0/16 <network_name>

docker network ls
```

### Embedded DNS
Docker h·ªó tr·ª£ relsove IP th√¥ng qua container name. DNS server ch·∫°y ·ªü 172.17.0.11




## Docker volumes and persistent data
Docker l∆∞u file t·∫°i `/var/lib/docker`. Docker ho·∫°t ƒë·ªông theo layered architecture. C√°c l·ªõp image s·∫Ω ƒë∆∞·ª£c t·∫°o th√¥ng qua dockerfile, khi ƒë√≥ n√≥ s·∫Ω tr·ªü th√†nh read-only. Khi ch·∫°y l·ªánh `docker run`, Docker s·∫Ω t·∫°o th√™m m·ªôt l·ªõp container layer, l·ªõp n√†y h·ªó tr·ª£ read-write, nh∆∞ng kh√¥ng persistent.

Gi·∫£ s·ª≠ n·∫øu m√¨nh copy source code v√†o trong image khi t·∫°o dockerfile th√¨ khi m√¨nh ch·ªânh s·ª≠a code, th·ª±c ra Docker ƒë√£ t·∫°o cho m√¨nh m·ªôt b·∫£n copy t·ª´ Image layers trong Container layers. Khi t·∫Øt container ƒëi th√¨ nh·ªØng th·ª© n·∫±m trong Container layers s·∫Ω b·ªã x√≥a s·∫°ch.

ƒê·ªÉ t·∫°o persistent storage, th√¨ m√¨nh c·∫ßn t·∫°o volume v√† k·∫øt n·ªëi v·ªõi container.

```bash
docker volume create <volume_name>
```

Khi ƒë√≥ volume s·∫Ω ƒë∆∞·ª£c t·∫°o ·ªü trong `/var/lib/docker/volumes/<volume_name>`. M√¨nh mount volume v√†o trong container b·∫±ng c√°ch:
```bash
docker run -v <volume_name>:<internal_endpoint> <image>
```

Ngo√†i ra, th√¨ volume kh√¥ng nh·∫•t thi·∫øt ph·∫£i ·ªü trong th∆∞ m·ª•c m·∫∑c ƒë·ªãnh c·ªßa Docker, m√¨nh c≈©ng c√≥ th·ªÉ mount volume ngo√†i b·∫±ng c√°ch specific absolute path c·ªßa n√≥. (C√°ch n√†y g·ªçi l√† bind mounting).

S·ª≠ d·ª•ng option `-v` ƒë√£ c≈© r·ªìi, gi·ªù ng∆∞·ªùi ta hay s·ª≠ d·ª•ng `--mount`:
```bash
docker run --mount type=bind,source=<external_volume>,target=<internal_volume> <image>
```






## Container orchestration
Ph·∫ßn n√†y x·ª©ng ƒë√°ng c√≥ m·ªôt post ri√™ng ƒë·ªÉ b√†n, v·∫≠y n√™n m√¨nh s·∫Ω kh√¥ng ƒëi s√¢u trong post n√†y. T√¨m hi·ªÉu chi ti·∫øt t·∫°i [ƒë√¢y](/handbook/technology/kubernetes/)

Container orchestration: solution that contain a set of tools and scripts that help monitoring, deploying containers efficiently.

- Docker Swarm
- Kubernetes (most popular)
- Mesos


### Docker Swarm
Docker Swarm is 2 main things:
- An enterprise-grade secure cluster of Docker hosts
- An engine for orchestrating microservices apps


### Kubernetes
Kubernetes is the most popular tool for deploying and managing containerized apps. Kubernetes has a pluggable container runtime interface (CRI) that makes it easy to swap-out Docker for a different container runtime. ‚Üí Docker has been replaced by containerd as the default container runtime in Kubernetes. 



## Best Practices

### Bring source code into Docker container
C√≥ 3 c√°ch ph·ªï bi·∫øn ƒë·ªÉ ƒë∆∞a source code v√†o trong docker container:
- S·ª≠ d·ª•ng Git Clone
- S·ª≠ d·ª•ng COPY
- S·ª≠ d·ª•ng Volume

ƒê·∫ßu ti√™n l√† s·ª≠ d·ª•ng git clone. ∆Øu ƒëi·ªÉm l√† vi·∫øt dockerfile kh√° d·ªÖ hi·ªÉu, h·∫øtüôÇ Nh∆∞·ª£c ƒëi·ªÉm l√† m·ªói l·∫ßn build image ƒë·ªÅu ph·∫£i rebuild l·∫°i, kh√¥ng ƒë·∫£m b·∫£o ƒë∆∞·ª£c b·∫£o m·∫≠t khi truy·ªÅn v√†o credentials (c√≥ c√°ch work around c∆° m√† s·∫Ω ph·ª©c t·∫°p h∆°n). C√°ch n√†y ch·ªâ n√™n d√πng v·ªõi c√°c project d·∫°ng open-source.

C√°ch th·ª© hai l√† s·ª≠ d·ª•ng COPY, nh∆∞·ª£c ƒëi·ªÉm v·∫´n l√† ph·∫£i rebuild l·∫°i image (khi code thay ƒë·ªïi). ∆Øu ƒëi·ªÉm h∆°n l√† kh√¥ng ph·∫£i c√†i Git, b·∫£o ƒë·∫£m b·∫£o m·∫≠t h∆°n. C√°ch n√†y kh√° ph·ªï bi·∫øn, chuy√™n d√πng ƒë·ªÉ t·∫°o production image. Ng∆∞·ªùi nh·∫≠n ch·ªâ c·∫ßn ch·∫°y dockerfile thay v√¨ ph·∫£i l·∫•y code v·ªÅ.

C√°ch cu·ªëi c√πng l√† s·ª≠ d·ª•ng Volume, thay v√¨ copy code v√†o trong image th√¨ m√¨nh ch·ªâ c·∫ßn mount th∆∞ m·ª•c project v√†o trong docker. M·ªçi thay ƒë·ªïi ·ªü code s·∫Ω hi·ªán di·ªán lu√¥n trong container (server c√≥ th·ªÉ hot reload ƒë∆∞·ª£c). C√°ch n√†y th√¨ ph√π h·ª£p l√†m development image, gi·∫£m th·ªùi gian ƒëi build image r·∫•t r·∫•t nhi·ªÅu. 


### Dockerize for Python project
```dockerfile
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
```
- `PYTHONDONTWRITEBYTECODE=1`: kh√¥ng cho Python t·∫°o c√°c file .pyc trong image
  - Container ch·ªâ ch·∫°y 1 l·∫ßn, vi·ªác generate ra .pyc kh√¥ng c√≥ √Ω nghƒ©a g√¨ c·∫£.

- `PYTHONUNBUFFERED=1`: kh√¥ng cho Python s·ª≠ d·ª•ng buffer khi ƒë·∫©y ra STDOUT.
  - ƒê·ªÅ ph√≤ng khi crash th√¨ Python s·∫Ω output to√†n b·ªô ra STDOUT, thay v√¨ gi·ªØ l·∫°i ·ªü buffer.
  - C√≥ th·ªÉ xem ƒë∆∞·ª£c STDOUT realtime.


## References
- [Docker Tutorial for Beginners - YouTube](https://www.youtube.com/watch?v=fqMOX6JJhGo&ab_channel=TraversyMedia)
- https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-1-lich-su-ByEZkWrEZQ0
- [Docker Official Docs](https://docs.docker.com)
- S√°ch Docker Deep Dive


## Contributors
- [minhdq99hp](mailto:minhdq99hp@gmail.com) $\dagger$
- [misaki](mailto:hieutt99@gmail.com)
