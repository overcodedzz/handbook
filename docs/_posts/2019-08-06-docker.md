---
title:  "Docker"
categories: technology
header:
    image: /images/2019-08-06-docker/header.png
toc: true
---
## References
- [Docker Official Docs](https://docs.docker.com)
- Sách Docker Deep Dive
- https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-1-lich-su-ByEZkWrEZQ0
- [Docker Tutorial for Beginners - YouTube](https://www.youtube.com/watch?v=fqMOX6JJhGo&ab_channel=TraversyMedia)



## Glossary
- namespaces: feature exists in Linux kernel
- control groups (cgroups): feature exists in Linux kernel
- daemon: a background process that handles requests for services such as print spooling and file transfers, and is dormant when not required.
- Image registries: the most common registry is Docker Hub
- Dangling image: an image that is no longer tagged, appears in <none>:<none>



## Advantages of Docker
- **Separate your applications from your infrastructure**, từ đó có thể deploy nhanh chóng hơn.


## Installation
Cài đặt bản Community Docker, với Mac và Win cần cài Docker Desktop (VM để chạy docker).

```bash
# check whether if Docker is installed.
docker version
```

You may need to add user account to group Docker to execute it without sudo.

## So sánh Virtualization vs Containerlization
Virtualization:
- Về tài nguyên: khi chạy máy ảo phải cung cấp dung lượng ổ cứng, cũng như ram cho máy ảo đó.
- Về thời gian: khởi động, shutdown khá lâu.

Containerlization:
- Trên máy chủ vật lý sẽ sinh ra được nhiều máy con (giống virtualization) nhưng tốt hơn ở chỗ các máy con (Guest OS) đều dùng chung phần nhân của máy mẹ (Host OS) và chia sẻ tài nguyên máy mẹ.
-> Khi nào cần tài nguyên thì cấp, cần bao nhiêu thì cấp bấy nhiêu -> tận dung tài nguyên tốt hơn.

## Architecture of Docker
2 Major components:

- Docker client
- Docker daemon (or Docker engine)

The daemon implements the runtime, API and everything else required to run Docker.

Client gọi Daemon thông qua local IPC/Unix socket ở /var/run/docker.sock




Docker engine: the core software that runs and manages containers.

- modular in design, built from many small specialized tools. (đây là kết quả của quá trình refactor nhằm chia nhỏ docker daemon).

![Docker%20f7723d3197124cc08906dd33e141a339/Untitled.png](Docker%20f7723d3197124cc08906dd33e141a339/Untitled.png)

![Docker%20f7723d3197124cc08906dd33e141a339/Untitled%201.png](Docker%20f7723d3197124cc08906dd33e141a339/Untitled%201.png)

runc: has a single purpose is to create containers. It's a standalone container runtime tool.

containerd: manage container lifecycle operations (start, stop, pause, rm,...) and some extended functionality (for images, volumes and networks) to make it easier to use in other projects. →use in k8s.

→container process is started as a child process of runc.

→entire container runtime is decoupled from the Docker daemon. → "daemonless containers" →có thể upgrade daemon mà không cần tắt container.

![Docker%20f7723d3197124cc08906dd33e141a339/Untitled%202.png](Docker%20f7723d3197124cc08906dd33e141a339/Untitled%202.png)

Process behind running an image

Khi container đã được khởi tạo, thì runc sẽ exit. Lúc này, containerd-shim process sẽ trở thành parent của container. Vai trò của shim:

- Keeping any STDIN and STDOUT streams open so that when the daemon is restared, the container doesn't terminate due to pipes being closed.
- Reports the container's exit status back to the daemon.

Docker daemon: some major functionality still exists: image management, image builds, the REST API, authentication, security, core networking, and orchestration

## Working with Images
![Docker Images](/assets/images/docker/Untitled%203.png)

An image is just a bunch of loosely-connected read-only layers, with each layer comprising one or more files. Images don't contain kernel - all containers running on a Docker host share access to the host's kernel. One image can have several tags (tags point to the same image id).

Multi-architecture Images: hầu hết các official image trên Docker Hub đều hỗ trợ multi-architecture mà không cần khai báo architecture.

```bash
docker image ls
docker pull [REPO:TAG]
docker search [QUERY_STRING]

# show all images
docker images

docker image inspect [IMAGE]

# delete image, you need to delete all dependent containers first
docker rmi <image>
# Delete all dangling images
docker image prune
# Delete all unused images (not currently used by any containers)
docker image prune -a

# Delete all images
docker image rm $(docker ls -q) -f


# RUN CONTAINER FROM AN IMAGE
docker run [IMAGE]
docker run -it [IMAGE]  # start a container
docker run -it [IMAGE] [CMD] # override the default command
# options:
# -i : interaction mode
# -d : detach mode
# -v <outside_volume>:<inside_volume> : mount volume
# -e MY_VAR=my_value : set envvars.
```

## Working with Containers
Docker sinh ra để chạy application, chứ không chạy để host OS, nếu không application nào thì nó sẽ tự động exit. Docker sẽ chạy ở hai chế độ attach và detach. Và docker cũng sẽ không listen ở stdin theo mặc định (non-interact mode).

```bash
docker ps       # show running containers
docker ps -a    # show all containers

docker start/stop [CONTAINER]

docker rm [CONTAINER]

# execute a command
docker exec [CONTAINER] [COMMAND]

docker attach [CONTAINER]

# show full details of a container
docker inspect [CONTAINER]

docker logs [CONTAINER]
```


```bash
# Press Ctrl + P Q to exit the container without terminating it.

```


## Create my own image

### Dockerfile
Dockerfile là một file text giúp Docker tạo image. Mỗi dòng sẽ bao gồm 2 phần: instruction và argument. Sau mỗi dòng lệnh, một layer sẽ được tạo ra để cache. -> Không mất công tạo lại toàn bộ khi có sai sót.


Ví dụ:
```dockerfile
#
FROM Ubuntu

RUN apt-get update
RUN apt-get install python

RUN pip install flask
RUN pip install flask-mysql

COPY . /opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
```

Tất cả image phải base trên một base image khác (OS).

```bash
# Tạo local image
docker build mydockerfile -t minhdq99hp/my-custom-image 

# Đẩy lên Docker Hub
docker push <custom_image>

```

#### Entrypoint vs Cmd
CMD: sử dụng để chạy default command khi container khởi động

```dockerfile
CMD command param1
# or
CMD ["command", "param1"]
```

Phải đảm bảo rằng `"command"` ở đây là một executable app.
Nếu sử dụng `docker run <image> [COMMAND]` thì command kia sẽ bị override.

Ví dụ:
```dockerfile
FROM Ubuntu
CMD sleep 5
```

```bash
docker run <image> sleep 10
# --> override to "sleep 10"
```

Ví dụ sử dụng Entrypoint:
```dockerfile
FROM Ubuntu
ENTRYPOINT ["sleep"]

# set default params
CMD ["5"]
```

```bash
docker run <image> 10

```

## Network
Khi tạo container thì nó sẽ có thể có 3 chế độ network: bridge (default), none, host

```bash
# bridge
docker run ubuntu
# none
docker run ubuntu --network
```

**Bridge**: private internal network created by docker on the host. All containers attach to this network, thường sẽ có dải 172.17.0.xxx. Các container có thể kết nối với nhau thông qua dải này.

**Host**: tự động mapping port, sử dụng host network -> Không thể sử dụng container trùng port.

**None**: cô lập.


### User-defined networks
Docker có thể chia nhiều private internal network.

```bash
docker network create --driver bridge --subnet 182.18.0.0/16 <network_name>

docker network ls
```

### Embedded DNS
Docker hỗ trợ relsove IP thông qua container name. DNS server chạy ở 172.17.0.11




## Storage
Docker lưu file tại `/var/lib/docker`. Docker hoạt động theo layered architecture. Các lớp image sẽ được tạo thông qua dockerfile, khi đó nó sẽ trở thành read-only. Khi chạy lệnh `docker run`, Docker sẽ tạo thêm một lớp container layer, lớp này hỗ trợ read-write, nhưng không persistent.

Giả sử nếu mình copy source code vào trong image khi tạo dockerfile thì khi mình chỉnh sửa code, thực ra Docker đã tạo cho mình một bản copy từ Image layers trong Container layers. Khi tắt container đi thì những thứ nằm trong Container layers sẽ bị xóa sạch.

Để tạo persistent storage, thì mình cần tạo volume và kết nối với container.

```bash
docker volume create <volume_name>
```

Khi đó volume sẽ được tạo ở trong `/var/lib/docker/volumes/<volume_name>`. Mình mount volume vào trong container bằng cách:
```bash
docker run -v <volume_name>:<internal_endpoint> <image>
```

Ngoài ra, thì volume không nhất thiết phải ở trong thư mục mặc định của Docker, mình cũng có thể mount volume ngoài bằng cách specific absolute path của nó. (Cách này gọi là bind mounting).

Sử dụng option `-v` đã cũ rồi, giờ người ta hay sử dụng `--mount`:
```bash
docker run --mount type=bind,source=<external_volume>,target=<internal_volume> <image>
```


## Dockerfile
Example:
```docker
FROM alpine
LABEL maintainer="nigelpoulton@hotmail.com"
RUN apk add --update nodejs nodejs-npm
COPY . /src
WORKDIR /src
RUN npm install
EXPOSE 8080
ENTRYPOINT ["node", "./app.js"]
```

Build new image
```bash
docker build [CONTEXT_PATH]
docker build [CONTEXT_PATH] -t [IMAGE_NAME:TAG]

# E.g:
# docker build -t my_img:latest .
```




## dockerignore
.dockerignore file

Thường thì sẽ ignore folder .git và .env

```docker
build:
  context: .
  dockerfile: DockerFilePython
```

Kinh nghiệm tạo Docker image:

```docker
FROM python:3.8

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

RUN apt-get update
RUN apt-get install ffmpeg -y

WORKDIR /code

COPY requirements.txt /code/

RUN pip install -r requirements.txt

COPY . /code/
```

Khi tạo Docker image thì luôn để những thành phần thay đổi nhiều xuống bên dưới. Ở ví dụ trên, cần copy requirements.txt vào trước cũng vì thế.




## Docker Compose
Thay vì chạy từng lệnh `docker run` riêng lẻ kia thì ta có thể sử dụng Docker compose. Về cơ bản thì là tạo một file `docker-compose.yml`, trong đó liệt kê các service kèm theo setting cần tạo.

Xong đó chạy lệnh này là toàn bộ service sẽ được bật.
```bash
docker-compose up
```

### Docker compose -build
Các service định nghĩa ở trong docker-compose không nhất thiết phải có sẵn image ở local hoặc Docker Hub.

Ví dụ:
```yml
vote:
    build: ./vote
    ports:
        - 5000:80
    links:
        - redis
```

Docker sẽ build image thông qua dockerfile ở trong thư mục `vote/` và tạo temp container để chạy.



## Docker Registry
- Public docker registry
- Private docker registry


## Docker Engine
By default, Docker doesn't limit


Limit CPU:
```bash
docker run --cpus=.5 <image>
```

Limit Memory:
```bash
docker run --mem=100 <image>
```


## Container orchestration
Contaier orchestration: solution that contain a set of tools and scripts that help monitoring, deploying containers efficiently.

Docker Swarm
Kubernetes (most popular)
Mesos


## Best Practices

### Bring source code into Docker container
Có 3 cách phổ biến để đưa source code vào trong docker container:
- Sử dụng Git Clone
- Sử dụng COPY
- Sử dụng Volume

Đầu tiên là sử dụng git clone. Ưu điểm là viết dockerfile khá dễ hiểu, hết🙂 Nhược điểm là mỗi lần build image đều phải rebuild lại, không đảm bảo được bảo mật khi truyền vào credentials (có cách work around cơ mà sẽ phức tạp hơn). Cách này chỉ nên dùng với các project dạng open-source.

Cách thứ hai là sử dụng COPY, nhược điểm vẫn là phải rebuild lại image (khi code thay đổi). Ưu điểm hơn là không phải cài Git, bảo đảm bảo mật hơn. Cách này khá phổ biến, chuyên dùng để tạo production image. Người nhận chỉ cần chạy dockerfile thay vì phải lấy code về.

Cách cuối cùng là sử dụng Volume, thay vì copy code vào trong image thì mình chỉ cần mount thư mục project vào trong docker. Mọi thay đổi ở code sẽ hiện diện luôn trong container (server có thể hot reload được). Cách này thì phù hợp làm development image, giảm thời gian đi build image rất rất nhiều. 



Kubernetes is the most popular tool for deploying and managing containerized apps. Kubernetes has a pluggable container runtime interface (CRI) that makes it easy to swap-out Docker for a different container runtime. →Docker has been replaced by containerd as the default container runtime in Kubernetes. 

Đọc thêm The Kubernetes Book